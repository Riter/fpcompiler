# Функциональное программирование: Пишем компилятор!

Цель этой лабораторной работы - придумать свой собственный функциональный язык программирования и разработать для него интерпретатор или компилятор.

Вы можете выполнить эту лабораторную работу в группе из 2 или 3 человек (или больше - но это требует одобрения преподавателя):

* 2 человека - компилятор/интерпретатор + примеры программ + краткая документация в README.md (вы можете заменить этот файл своей собственной документацией)
* 3 человека - компилятор/интерпретатор + примеры программ + более подробная документация на GitHub Pages

## Задача

Ваша цель - изобрести и реализовать собственный функциональный язык программирования. Требования:

* Он должен тесно следовать парадигме функционального программирования, на основе либо [лямбда-исчисления](https://en.wikipedia.org/wiki/Lambda_calculus), либо [комбинаторной логики](https://en.wikipedia.org/wiki/Combinatory_logic).
* Он должен быть более или менее универсальным, т.е. реализовывать рекурсию. В идеале - полным по Тьюрингу.
* Как минимум, язык должен позволять запрограммировать функцию для расчета факториала.

> Имейте в виду, что написание парсеров - это утомительная задача, поэтому постарайтесь сделать синтаксис языка как можно проще.

Для вдохновения:

* Изучите [LISP](https://books.ifmo.ru/file/pdf/1918.pdf) - язык программирования с очень простым синтаксисом.
* Комбинаторные парсеры и библиотеку [fparsec](https://www.quanttec.com/fparsec/), если вы хотите реализовать язык с более сложным синтаксисом.
* [Top-Down Parser на F#](https://github.com/fholm/Vaughan).
* Интересный блог пост о [парсинге на F#](https://www.erikschierboom.com/2016/12/10/parsing-text-in-fsharp/).
* Парсинг с использованием инструментов [FsLex и FsYacc](https://realfiction.net/posts/lexing-and-parsing-in-f/) (не рекомендуется).
* Реализация [Scheme в F#](https://github.com/AshleyF/FScheme) - вы можете ознакомиться с этим проектом для вдохновения, но не заимствуйте код оттуда!

## Критерии оценки

* Универсальность
* Примеры программ (включая факториал, но не ограничиваясь им)
* Оригинальность и красота синтаксиса
* Документированность
* Красота реализации

Предпочтительный язык реализации - F#.

В документации явно укажите, какие функции языка вы реализовали:

* [+] Именованные переменные (`let`)
* [+] Рекурсия
* [+] Ленивое вычисление
* [+] Функции
* [+] Замыкания
* [ ] Библиотечные функции: ввод-вывод файлов
* [+] Списки / Последовательности
* [+] Библиотечные функции: списки/последовательности

## Репозиторий

Вам необходимо работать над кодом в репозитории GitHub Classroom. После завершения задачи **настоятельно рекомендуется** форкнуть этот код в свои собственные аккаунты GitHub, чтобы он служил вашим портфолио.

## Пошаговая работа

Поскольку проект довольно большой, его нужно делать поэтапно, загружая ваш код в GitHub на каждом этапе:

* Этап 1: Разработка абстрактного синтаксического дерева и парсера для вашего языка + одна примерная программа.
* Этап 2: Разработка интерпретатора/компилятора для вашего языка.
* Этап 3: Написание примеров программ и документации.

> Конечно, вы можете изменять язык на более поздних этапах, если посчитаете это нужным.

## Авторы

Не забудьте упомянуть свою команду в файле README.md, указав также, кто что делал. Также файл README.md должен включать краткое руководство по вашему языку и некоторые короткие примеры кода.

Имя | Роль в проекте
------------------|---------------------
Пирязев Михаил Александрович | Разработка документации, парсера
Бычков Дмитрий Андреевич| Разработка парсера
Иванов Илья Михайлович| Разработка интерпретатора

### Описание модулей

#### AST.fs

Модуль `AST` определяет абстрактное синтаксическое дерево (AST) для нашего функционального языка программирования. AST используется для представления синтаксической структуры программ. Оно включает различные типы выражений, которые поддерживает наш язык:

- `Op` - Операция с операторами (например, `+`, `-`).
- `Num` - Числовые литералы.
- `Str` - Строковые литералы.
- `Id` - Идентификаторы переменных и функций.
- `Bool` - Булевы значения (true/false).
- `Cond` - Условные выражения (if-then-else).
- `Var` - Определение переменных.
- `Set` - Присваивание значений переменным.
- `Func` - Определение функций.
- `Call` - Вызов функций.
- `Print` - Вывод выражений.
- `Simple` - Простые выражения (ключевые слова).
- `SimpleOp` - Простые операции.
- `SimpleList` - Список выражений.
- `SimpleArgs` - Список аргументов функций.

Каждое выражение может включать вложенные выражения и окружение переменных (для функций).

#### Lexer.fs

Модуль `Lexer` отвечает за лексический анализ исходного кода. Он преобразует входной текст программы в последовательность токенов. Токены представляют собой элементарные синтаксические единицы, такие как ключевые слова, операторы, идентификаторы и литералы.

- `Token` - определяет типы токенов, включая операторы (`Op`), числовые литералы (`Num`), строковые литералы (`Str`), идентификаторы (`Id`), открывающие и закрывающие скобки (`LParen` и `RParen`).
- `tokenize` - основная функция, которая принимает исходный код и разбивает его на токены. Она обрабатывает пробелы, строки, идентификаторы и числа, используя вспомогательные функции `readString`, `readId`, `readNum`.

#### SuperParser2004.fs

Модуль `SuperParser2004` выполняет синтаксический анализ последовательности токенов, создавая абстрактное синтаксическое дерево (AST) программы.

- `parse` - основная функция, которая принимает список токенов и возвращает AST. Она включает в себя несколько вспомогательных функций:
  - `parseExprs` - рекурсивно обрабатывает список токенов, создавая список выражений.
  - `buildAst` - преобразует список выражений в соответствующие узлы AST, основываясь на синтаксических конструкциях языка.

Функция `parse` обрабатывает такие конструкции, как определения функций, переменные, присваивания, условные выражения, вызовы функций и операции. Она также включает проверку на наличие оставшихся необработанных токенов, что помогает выявить ошибки синтаксического анализа.


### Interpretator.fs

Модуль `Interpretator` отвечает за выполнение программ, написанных на нашем функциональном языке программирования. Интерпретатор обрабатывает абстрактное синтаксическое дерево (AST), созданное парсером, и вычисляет результаты выражений.

#### Основные функции

##### eval
Функция `eval` рекурсивно вычисляет значение выражений, основываясь на текущем окружении (env). Окружение представляет собой карту, связывающую идентификаторы с их значениями.

```fsharp
let rec eval env expr = 
    match expr with
    | Expr.Num(n) -> Expr.Num(n), env
    | Expr.Bool(b) -> Expr.Bool(b), env
    | Expr.Id(id) -> 
        let value = Map.find id env
        value, env
    | Expr.Func(name, parameters, body, _, arity) ->
        let updatedEnv = Map.add name (Expr.Func(name, parameters, body, env, arity)) env
        Expr.Bool(true), updatedEnv  // Возвращаем Bool просто для обозначения успешного определения функции
    | Expr.Call(funcName, Expr.SimpleList(arguments), arity) ->
        let Expr.Func(_, Expr.SimpleArgs(params), body, funcEnv, _) = Map.find funcName env
        let updatedEnv = List.fold2 (fun accEnv param arg -> 
            let argValue, _ = eval env arg
            Map.add param argValue accEnv
        ) funcEnv params arguments
        eval updatedEnv body
    | Expr.Op(op, operands) ->
        let evaluatedOperands = List.map (fun e -> fst (eval env e)) operands
        let result = match op, evaluatedOperands with
            | "+", [Expr.Num(x); Expr.Num(y)] -> Expr.Num(x + y)
            | "-", [Expr.Num(x); Expr.Num(y)] -> Expr.Num(x - y)
            | "*", [Expr.Num(x); Expr.Num(y)] -> Expr.Num(x * y)
            | "/", [Expr.Num(x); Expr.Num(y)] -> Expr.Num(x / y)
            | _ -> failwith "eval ERROR: Unsupported operator or operand types"
        result, env
    | Expr.Cond(condition, thenExpr, elseExpr) ->
        let Expr.Bool(condResult), _ = eval env condition
        if condResult then eval env thenExpr else eval env elseExpr
```

#### Обработка выражений

1. **Числа и булевы значения**:
   - `Expr.Num(n)` и `Expr.Bool(b)` возвращают свои значения и текущее окружение без изменений.

2. **Идентификаторы**:
   - `Expr.Id(id)` ищет значение идентификатора в окружении и возвращает его.

3. **Функции**:
   - `Expr.Func(name, parameters, body, _, arity)` добавляет функцию в окружение и возвращает булево значение для обозначения успешного определения функции.

4. **Вызовы функций**:
   - `Expr.Call(funcName, Expr.SimpleList(arguments), arity)` находит определение функции в окружении, создает новое окружение для функции, связывая аргументы с их значениями, и вычисляет тело функции.

5. **Операции**:
   - `Expr.Op(op, operands)` вычисляет значения операндов и выполняет соответствующую арифметическую операцию. Поддерживаются операции `+`, `-`, `*` и `/`.

6. **Условные выражения**:
   - `Expr.Cond(condition, thenExpr, elseExpr)` сначала вычисляет условие. Если результат истинный, вычисляется выражение `thenExpr`, иначе `elseExpr`.

Интерпретатор позволяет выполнять различные выражения и функции, написанные на нашем языке. Например, вычисление факториала может быть реализовано с использованием рекурсивной функции. Интерпретатор обеспечит корректное вычисление значений и поддержку функциональных возможностей языка, таких как замыкания и рекурсия.

# Реализация основных концепций в проекте

#### 1. Именованные переменные  (let)

В данной реализации используется конструкция  **var** для объявления переменных, а не  **let**, что является стандартом во многих функциональных языках. Пример объявления переменной:
```
var x = 10
```
В коде это реализуется через тип  Expr.Var в AST и обрабатывается в  eval функции в  Interpretator.fs.

####  2. Рекурсия

Рекурсия поддерживается через определение функций, которые могут вызывать сами себя. Пример рекурсивной функции:
```
def factorial n = if n == 1 then 1 else n * factorial(n - 1)
```
Рекурсивные вызовы функций обрабатываются в  Expr.Call в  eval функции, где функция может вызывать сама себя.
#### 3. Ленивое вычисление

Ленивое вычисление не реализовано напрямую в данном проекте. Однако, можно имитировать ленивое вычисление через функции, возвращающие другие функции или используя специальные конструкции для отложенных вычислений.

####  4. Функции

Функции определяются с помощью  def и обрабатываются в  Expr.Func в AST. Они могут принимать параметры и возвращать значения. Пример:
```
def add x y = x + y
```
Функции поддерживают замыкания, так как они могут захватывать и использовать переменные из внешнего окружения.
#### 5. Замыкания

Замыкания реализованы так, что функции могут использовать переменные, определенные вне их тела. Это достигается за счет сохранения окружения  (env) при определении функции:
```
Expr.Func(name, parameters, body, env, arity)
```
Таким образом, функция  "запоминает" окружение, в котором она была создана.
#### 6. Библиотечные функции: ввод-вывод файлов
В текущей реализации нет встроенной поддержки ввода-вывода файлов. Для добавления такой функциональности потребуется интеграция с F# API для работы с файлами.

#### 7. Списки  / Последовательности

Списки поддерживаются через конструкцию  SimpleList в AST. Пример использования:
```
[1, 2, 3, 4]
```
Списки обрабатываются в  Expr.SimpleList и могут быть использованы в различных выражениях и функциях.

#### 8. Библиотечные функции: списки/последовательности

Операции над списками, такие как map, reduce, filter, не реализованы в данной версии и могут быть добавлены пользователем через определение соответствующих функций в языке.

#### 9. Библиотечные функции: списки/последовательности

Функция **sout** используется для вывода значений. Вот как это может выглядеть в вашем языке:
```
sout("Hello, World!")
```

Таким образом, хотя базовая инфраструктура языка уже поддерживает ключевые функциональные концепции, расширение его возможностей требует дополнительной работы и возможно интеграции с существующими библиотеками F#. Это позволит использовать полный потенциал функционального программирования и улучшить возможности языка для решения более сложных задач.



